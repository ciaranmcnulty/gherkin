<?php

/**
 * This code was generated by Berp (http://https://github.com/gasparnagy/berp/).
 *
 * Changes to this file may cause incorrect behavior and will be lost if
 * the code is regenerated.
 */

@using Berp;
@helper CallProduction(ProductionRule production)
{
    switch(production.Type) {
        case ProductionRuleType.Start:
            @:$this->startRule($context, RuleType::@production.RuleName);
            break;
        case ProductionRuleType.End:
            @:$this->endRule($context, RuleType::@production.RuleName);
            break;
        case ProductionRuleType.Process:
            @:$this->build($context, $token);
            break;
    }
}
@helper HandleParserError(IEnumerable<string> expectedTokens, State state)
{<text>
        $stateComment = "State: @state.Id - @Raw(state.Comment)";
        $token->detach();
        $expectedTokens =["@Raw(string.Join("\", \"", expectedTokens))"];
        $error = $token->isEOF()
            ? new ParserException\UnexpectedEofException($token, $expectedTokens, $stateComment)
            : new ParserException\UnexpectedTokenException($token, $expectedTokens, $stateComment);

        if ($this->stopAtFirstError) {
            throw $error;
        }

        $this->addError($context, $error);

        return @state.Id;
</text>}
@helper matchToken(TokenType tokenType)
{<text>$this->match_@(tokenType)($context, $token)</text>}

namespace Cucumber\Gherkin;

interface RuleType {
    const None = "None";
    @foreach(var rule in Model.RuleSet.Where(r => !r.TempRule))
    {<text>    const @rule.Name.Replace("#", "_") = "@rule.Name.Replace("#", "_")"; // @rule.ToString(true)
</text>}
}

interface TokenType {
    const None = "None";
    @foreach(var rule in Model.RuleSet.TokenRules)
    {<text>    const @rule.Name.Replace("#", "") = "@rule.Name.Replace("#", "")";
</text>}
}

final class @Model.ParserClassName
{
    private $builder;

    public function __construct(TokenBuilderInterface $builder)
    {
        $this->builder = $builder;
    }

    public function parse(TokenScannerInterface $tokenScanner, TokenMatcherInterface $tokenMatcher) : string
    {
        $this->builder->reset();
        $tokenMatcher->reset();

        $context = new ParserContext($tokenScanner, $tokenMatcher, [], []);

        $this->startRule($context, RuleType::@Model.RuleSet.StartRule.Name);

        $state = 0;
        do {
            $token = $this->readToken($context);
            $state = $this->matchToken($state, $token, $context);
        } while (!$token->isEOF());

        $this->endRule($context, RuleType::GherkinDocument);

        if ($context->errors) {
            // Todo: throw a composite exception
        }

        return $this->builder->getResult();
    }

    private function build(ParserContext $context, Token $token)
    {
        $this->handleAstError($context, function() use ($token)
        {
            $this->builder->build($token);
        });
    }

    private function startRule(ParserContext $context, string $ruleType)
    {
        $this->handleAstError($context, function() use ($ruleType)
        {
            $this->builder->startRule($ruleType);
        });
    }

    private function endRule(ParserContext $context, string $ruleType)
    {
        $this->handleAstError($context, function() use ($ruleType)
        {
            $this->builder->endRule($ruleType);
        });
    }

    private function handleAstError(ParserContext $context, callable $action)
    {
        return $this->handleExternalError($context, $action);
    }

    private function handleExternalError(ParserContext $context, callable $action, $defaultValue = null)
    {
        /** todo: support stopAtFirstError */

        /** todo: support CompositeParserException */

        try {
            return $action();
        }
        catch (ParserException $error) {
            $this->addError($context, $error);
        }

        return $defaultValue;
    }

    private function readToken(ParserContext $context) : Token
    {
        return count($context->tokenQueue) > 0 ? array_shift($context->tokenQueue) : $context->tokenScanner->read();
    }
@foreach(var rule in Model.RuleSet.TokenRules)
{<text>
    private function match_@(rule.Name.Replace("#", ""))(ParserContext $context, Token $token) : bool
    {
        @if (rule.Name != "#EOF") {
        @:if ($token->isEOF()) {
        @:    return false;
        @:}
        }
        return $this->handleExternalError($context, function () use ($context, $token) {
                return $context->tokenMatcher->match_@(rule.Name.Replace("#", ""))($token);
        }, false);
    }</text>
}

    private function matchToken(int $state, Token $token, ParserContext $context) : int
    {
        switch($state) {
        @foreach(var state in Model.States.Values.Where(s => !s.IsEndState))
        {
            @:case @state.Id:
                @:$newState = $this->matchTokenAt_@(state.Id)($token, $context);
                @:break;
        }
            default:
                throw new IllegalStateException("Unknown state: " + $state);
        }

        return $newState;
    }
@foreach(var state in Model.States.Values.Where(s => !s.IsEndState))
{
<text>
    // @Raw(state.Comment)
    private function matchTokenAt_@(state.Id)(Token $token, ParserContext $context) : int
    {
        @foreach(var transition in state.Transitions)
        {
        @:if (@matchToken(transition.TokenType)) {
            if (transition.LookAheadHint != null)
            {
            @:if ($this->lookahead_@(transition.LookAheadHint.Id)($context, $token)) {
            }
            foreach(var production in transition.Productions)
            {
                @CallProduction(production)
            }
            @:
            @:return @transition.TargetState;
            if (transition.LookAheadHint != null)
            {
            @:}
            }
        @:}
        }
        @HandleParserError(state.Transitions.Select(t => "#" + t.TokenType.ToString()).Distinct(), state)
    }</text>
}
}

